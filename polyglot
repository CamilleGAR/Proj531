# - * - codage: utf-8 - * -
#
# Ce fichier fait partie de la bibliothèque python-chess.
# Copyright (C) 2012-2019 Niklas Fiekas <niklas.fiekas@backscattering.de>
#
# Ce programme est un logiciel libre: vous pouvez le redistribuer et / ou modifier
# sous les termes de la licence publique générale GNU telle que publiée par
# la Free Software Foundation, soit la version 3 de la licence, soit
# (à votre choix) toute version ultérieure.
#
# Ce programme est distribué dans l’espoir que ce sera utile,
# mais SANS AUCUNE GARANTIE; sans même la garantie implicite de
# QUALITÉ MARCHANDE ou ADAPTATION À UN USAGE PARTICULIER. Voir le
# Licence publique générale GNU pour plus de détails.
#
# Vous devriez avoir reçu une copie de la licence publique générale GNU.
# avec ce programme. Sinon, voir <http://www.gnu.org/licenses/>.

importer des échecs
importer des collections
structure d' importation
importation os
importer mmap
importer au hasard
dactylographie d' importation

à partir des types import TracebackType
de taper l' importation appelable, Container, Iterator, Liste, en option, le type, l' Union


PathLike = Union [ str , octets ]


ENTRY_STRUCT  = struct.Struct ( " > QHHI " )


POLYGLOT_RANDOM_ARRAY  = [
    0x 9D39247E33776D41 , 0x 2AF7398005AAA5C7 , 0x 44DB015024623547 , 0x 9C15F73E62A76AE2 ,
    0x 75834465489C0C89 , 0x 3290AC3A203001BF , 0x 0FBBAD1F61042279 , 0x E83A908FF2FB60CA ,
    0x 0D7E765D58755C10 , 0x 1A083822CEAFE02D , 0x 9605D5F0E25EC3B0 , 0x D021FF5CD13A2ED5 ,
    0x 40BDF15D4A672E32 , 0x 011355146FD56395 , 0x 5DB4832046F3D9E5 , 0x 239F8B2D7FF719CC ,
    0x 05D1A1AE85B49AA1 , 0x 679F848F6E8FC971 , 0x 7449BBFF801FED0B , 0x 7D11CDB1C3B7ADF0 ,
    0x 82C7709E781EB7CC , 0x F3218F1C9510786C , 0x 331478F3AF51BBE6 , 0x 4BB38DE5E7219443 ,
    0x AA649C6EBCFD50FC , 0x 8DBD98A352AFD40B , 0x 87D2074B81D79217 , 0x 19F3C751D3E92AE1 ,
    0x B4AB30F062B19ABF , 0x 7B0500AC42047AC4 , 0x C9452CA81A09D85D , 0x 24AA6C514DA27500 ,
    0x 4C9F34427501B447 , 0x 14A68FD73C910841 , 0x A71B9B83461CBD93 , 0x 03488B95B0F1850F ,
    0x 637B2B34FF93C040 , 0x 09D1BC9A3DD90A94 , 0x 3575668334A1DD3B , 0x 735E2B97A4C45A23 ,
    0x 18727070F1BD400B , 0x 1FCBACD259BF02E7 , 0x D310A7C2CE9B6555 , 0x BF983FE0FE5D8244 ,
    0x 9F74D14F7454A824 , 0x 51EBDC4AB9BA3035 , 0x 5C82C505DB9AB0FA , 0x FCF7FE8A3430B241 ,
    0x 3253A729B9BA3DDE , 0x 8C74C368081B3075 , 0x B9BC6C87167C33E7 , 0x 7EF48F2B83024E20 ,
    0x 11D505D4C351BD7F , 0x 6568FCA92C76A243 , 0x 4DE0B0F40F32A7B8 , 0x 96D693460CC37E5D ,
    0x 42E240CB63689F2F , 0x 6D2BDCDAE2919661 , 0x 42880B0236E4D951 , 0x 5F0F4A5898171BB6 ,
    0x 39F890F579F92F88 , 0x 93C5B5F47356388B , 0x 63DC359D8D231B78 , 0x EC16CA8AEA98AD76 ,
    0x 5355F900C2A82DC7 , 0x 07FB9F855A997142 , 0x 5093417AA8A7ED5E , 0x 7BCBC38DA25A7F3C ,
    0x 19FC8A768CF4B6D4 , 0x 637A7780DECFC0D9 , 0x 8249A47AEE0E41F7 , 0x 79AD695501E7D1E8 ,
    0x 14ACBAF4777D5776 , 0x F145B6BECCDEA195 , 0x DABF2AC8201752FC , 0x 24C3C94DF9C8D3F6 ,
    0x BB6E2924F03912EA , 0x 0CE26C0B95C980D9 , 0x A49CD132BFBF7CC4 , 0x E99D662AF4243939 ,
    0x 27E6AD7891165C3F , 0x 8535F040B9744FF1 , 0x 54B3F4FA5F40D873 , 0x 72B12C32127FED2B ,
    0x EE954D3C7B411F47 , 0x 9A85AC909A24EAA1 , 0x 70AC4CD9F04F21F5 , 0x F9B89D3E99A075C2 ,
    0x 87B3E2B2B5C907B1 , 0x A366E5B8C54F48B8 , 0x AE4A9346CC3F7CF2 , 0x 1920C04D47267BBD ,
    0x 87BF02C6B49E2AE9 , 0x 092237AC237F3859 , 0x FF07F64EF8ED14D0 , 0x 8DE8DCA9F03CC54E ,
    0x 9C1633264DB49C89 , 0x B3F22C3D0B0B38ED , 0x 390E5FB44D01144B , 0x 5BFEA5B4712768E9 ,
    0x 1E1032911FA78984 , 0x 9A74ACB964E78CB3 , 0x 4F80F7A035DAFB04 , 0x 6304D09A0B3738C4 ,
    0x 2171E64683023A08 , 0x 5B9B63EB9CEFF80C , 0x 506AACF489889342 , 0x 1881AFC9A3A701D6 ,
    0x 6503080440750644 , 0x DFD395339CDBF4A7 , 0x EF927DBCF00C20F2 , 0x 7B32F7D1E03680EC ,
    0x B9FD7620E7316243 , 0x 05A7E8A57DB91B77 , 0x B5889C6E15630A75 , 0x 4A750A09CE9573F7 ,
    0x CF464CEC899A2F8A , 0x F538639CE705B824 , 0x 3C79A0FF5580EF7F , 0x EDE6C87F8477609D ,
    0x 799E81F05BC93F31 , 0x 86536B8CF3428A8C , 0x 97D7374C60087B73 , 0x A246637CFF328532 ,
    0x 043FCAE60CC0EBA0 , 0x 920E449535DD359E , 0x 70EB093B15B290CC , 0x 73A1921916591CBD ,
    0x 56436C9FE1A1AA8D , 0x EFAC4B70633B8F81 , 0x BB215798D45DF7AF , 0x 45F20042F24F1768 ,
    0x 930F80F4E8EB7462 , 0x FF6712FFCFD75EA1 , 0x AE623FD67468AA70 , 0x DD2C5BC84BC8D8FC ,
    0x 7EED120D54CF2DD9 , 0x 22FE545401165F1C , 0x C91800E98FB99929 , 0x 808BD68E6AC10365 ,
    0x DEC468145B7605F6 , 0x 1BEDE3A3AEF53302 , 0x 43539603D6C55602 , 0x AA969B5C691CCB7A ,
    0x A87832D392EFEE56 , 0x 65942C7B3C7E11AE , 0x DED2D633CAD004F6 , 0x 21F08570F420E565 ,
    0x B415938D7DA94E3C , 0x 91B859E59ECB6350 , 0x 10CFF333E0ED804A , 0x 28AED140BE0BB7DD ,
    0x C5CC1D89724FA456 , 0x 5648F680F11A2741 , 0x 2D255069F0B7DAB3 , 0x 9BC5A38EF729ABD4 ,
    0x EF2F054308F6A2BC , 0x AF2042F5CC5C2858 , 0x 480412BAB7F5BE2A , 0x AEF3AF4A563DFE43 ,
    0x 19AFE59AE451497F , 0x 52593803DFF1E840 , 0x F4F076E65F2CE6F0 , 0x 11379625747D5AF3 ,
    0x BCE5D2248682C115 , 0x 9DA4243DE836994F , 0x 066F70B33FE09017 , 0x 4DC4DE189B671A1C ,
    0x 51039AB7712457C3 , 0x C07A3F80C31FB4B4 , 0x B46EE9C5E64A6E7C , 0x B3819A42ABE61C87 ,
    0x 21A007933A522A20 , 0x 2DF16F761598AA4F , 0x 763C4A1371B368FD , 0x F793C46702E086A0 ,
    0x D7288E012AEB8D31 , 0x DE336A2A4BC1C44B , 0x 0BF692B38D079F23 , 0x 2C604A7A177326B3 ,
    0x 4850E73E03EB6064 , 0x CFC447F1E53C8E1B , 0x B05CA3F564268D99 , 0x 9AE182C8BC9474E8 ,
    0x A4FC4BD4FC5558CA , 0x E755178D58FC4E76 , 0x 69B97DB1A4C03DFE , 0x F9B5B7C4ACC67C96 ,
    0x FC6A82D64B8655FB , 0x 9C684CB6C4D24417 , 0x 8EC97D2917456ED0 , 0x 6703DF9D2924E97E ,
    0x C547F57E42A7444E , 0x 78E37644E7CAD29E , 0x FE9A44E9362F05FA , 0x 08BD35CC38336615 ,
    0x 9315E5EB3A129ACE , 0x 94061B871E04DF75 , 0x DF1D9F9D784BA010 , 0x 3BBA57B68871B59D ,
    0x D2B7ADEEDED1F73F , 0x F7A255D83BC373F8 , 0x D7F4F2448C0CEB81 , 0x D95BE88CD210FFA7 ,
    0x 336F52F8FF4728E7 , 0x A74049DAC312AC71 , 0x A2F61BB6E437FDB5 , 0x 4F2A5CB07F6A35B3 ,
    0x 87D380BDA5BF7859 , 0x 16B9F7E06C453A21 , 0x 7BA2484C8A0FD54E , 0x F3A678CAD9A2E38C ,
    0x 39B0BF7DDE437BA2 , 0x FCAF55C1BF8A4424 , 0x 18FCF680573FA594 , 0x 4C0563B89F495AC3 ,
    0x 40E087931A00930D , 0x 8CFFA9412EB642C1 , 0x 68CA39053261169F , 0x 7A1EE967D27579E2 ,
    0x 9D1D60E5076F5B6F , 0x 3810E399B6F65BA2 , 0x 32095B6D4AB5F9B1 , 0x 35CAB62109DD038A ,
    0x A90B24499FCFAFB1 , 0x 77A225A07CC2C6BD , 0x 513E5E634C70E331 , 0x 4361C0CA3F692F12 ,
    0x D941ACA44B20A45B , 0x 528F7C8602C5807B , 0x 52AB92BEB9613989 , 0x 9D1DFA2EFC557F73 ,
    0x 722FF175F572C348 , 0x 1D1260A51107FE97 , 0x 7A249A57EC0C9BA2 , 0x 04208FE9E8F7F2D6 ,
    0x 5A110C6058B920A0 , 0x 0CD9A497658A5698 , 0x 56FD23C8F9715A4C , 0x 284C847B9D887AAE ,
    0x 04FEABFBBDB619CB , 0x 742E1E651C60BA83 , 0x 9A9632E65904AD3C , 0x 881B82A13B51B9E2 ,
    0x 506E6744CD974924 , 0x B0183DB56FFC6A79 , 0x 0ED9B915C66ED37E , 0x 5E11E86D5873D484 ,
    0x F678647E3519AC6E , 0x 1B85D488D0F20CC5 , 0x DAB9FE6525D89021 , 0x 0D151D86ADB73615 ,
    0x A865A54EDCC0F019 , 0x 93C42566AEF98FFB , 0x 99E7AFEABE000731 , 0x 48CBFF086DDF285A ,
    0x 7F9B6AF1EBF78BAF , 0x 58627E1A149BBA21 , 0x 2CD16E2ABD791E33 , 0x D363EFF5F0977996 ,
    0x 0CE2A38C344A6EED , 0x 1A804AADB9CFA741 , 0x 907F30421D78C5DE , 0x 501F65EDB3034D07 ,
    0x 37624AE5A48FA6E9 , 0x 957BAF61700CFF4E , 0x 3A6C27934E31188A , 0x D49503536ABCA345 ,
    0x 088E049589C432E0 , 0x F943AEE7FEBF21B8 , 0x 6C3B8E3E336139D3 , 0x 364F6FFA464EE52E ,
    0x D60F6DCEDC314222 , 0x 56963B0DCA418FC0 , 0x 16F50EDF91E513AF , 0x EF1955914B609F93 ,
    0x 565601C0364E3228 , 0x ECB53939887E8175 , 0x BAC7A9A18531294B , 0x B344C470397BBA52 ,
    0x 65D34954DAF3CEBD , 0x B4B81B3FA97511E2 , 0x B422061193D6F6A7 , 0x 071582401C38434D ,
    0x 7A13F18BBEDC4FF5 , 0x BC4097B116C524D2 , 0x 59B97885E2F2EA28 , 0x 99170A5DC3115544 ,
    0x 6F423357E7C6A9F9 , 0x 325928EE6E6F8794 , 0x D0E4366228B03343 , 0x 565C31F7DE89EA27 ,
    0x 30F5611484119414 , 0x D873DB391292ED4F , 0x 7BD94E1D8E17DEBC , 0x C7D9F16864A76E94 ,
    0x 947AE053EE56E63C , 0x C8C93882F9475F5F , 0x 3A9BF55BA91F81CA , 0x D9A11FBB3D9808E4 ,
    0x 0FD22063EDC29FCA , 0x B3F256D8ACA0B0B9 , 0x B03031A8B4516E84 , 0x 35DD37D5871448AF ,
    0x E9F6082B05542E4E , 0x EBFAFA33D7254B59 , 0x 9255ABB50D532280 , 0x B9AB4CE57F2D34F3 ,
    0x 693501D628297551 , 0x C62C58F97DD949BF , 0x CD454F8F19C5126A , 0x BBE83F4ECC2BDECB ,
    0x DC842B7E2819E230 , 0x BA89142E007503B8 , 0x A3BC941D0A5061CB , 0x E9F6760E32CD8021 ,
    0x 09C7E552BC76492F , 0x 852F54934DA55CC9 , 0x 8107FCCF064FCF56 , 0x 098954D51FFF6580 ,
    0x 23B70EDB1955C4BF , 0x C330DE426430F69D , 0x 4715ED43E8A45C0A , 0x A8D7E4DAB780A08D ,
    0x 0572B974F03CE0BB , 0x B57D2E985E1419C7 , 0x E8D9ECBE2CF3D73F , 0x 2FE4B17170E59750 ,
    0x 11317BA87905E790 , 0x 7FBF21EC8A1F45EC , 0x 1725CABFCB045B00 , 0x 964E915CD5E2B207 ,
    0x 3E2B8BCBF016D66D , 0x BE7444E39328A0AC , 0x F85B2B4FBCDE44B7 , 0x 49353FEA39BA63B1 ,
    0x 1DD01AAFCD53486A , 0x 1FCA8A92FD719F85 , 0x FC7C95D827357AFA , 0x 18A6A990C8B35EBD ,
    0x CCCB7005C6B9C28D , 0x 3BDBB92C43B17F26 , 0x AA70B5B4F89695A2 , 0x E94C39A54A98307F ,
    0x B7A0B174CFF6F36E , 0x D4DBA84729AF48AD , 0x 2E18BC1AD9704A68 , 0x 2DE0966DAF2F8B1C ,
    0x B9C11D5B1E43A07E , 0x 64972D68DEE33360 , 0x 94628D38D0C20584 , 0x DBC0D2B6AB90A559 ,
    0x D2733C4335C6A72F , 0x 7E75D99D94A70F4D , 0x 6CED1983376FA72B , 0x 97FCAACBF030BC24 ,
    0x 7B77497B32503B12 , 0x 8547EDDFB81CCB94 , 0x 79999CDFF70902CB , 0x CFFE1939438E9B24 ,
    0x 829626E3892D95D7 , 0x 92FAE24291F2B3F1 , 0x 63E22C147B9C3403 , 0x C678B6D860284A1C ,
    0x 5873888850659AE7 , 0x 0981DCD296A8736D , 0x 9F65789A6509A440 , 0x 9FF38FED72E9052F ,
    0x E479EE5B9930578C , 0x E7F28ECD2D49EECD , 0x 56C074A581EA17FE , 0x 5544F7D774B14AEF ,
    0x 7B3F0195FC6F290F , 0x 12153635B2C0CF57 , 0x 7F5126DBBA5E0CA7 , 0x 7A76956C3EAFB413 ,
    0x 3D5774A11D31AB39 , 0x 8A1B083821F40CB4 , 0x 7B4A38E32537DF62 , 0x 950113646D1D6E03 ,
    0x 4DA8979A0041E8A9 , 0x 3BC36E078F7515D7 , 0x 5D0A12F27AD310D1 , 0x 7F9D1A2E1EBE1327 ,
    0x DA3A361B1C5157B1 , 0x DCDD7D20903D0C25 , 0x 36833336D068F707 , 0x CE68341F79893389 ,
    0x AB9090168DD05F34 , 0x 43954B3252DC25E5 , 0x B438C2B67F98E5E9 , 0x 10DCD78E3851A492 ,
    0x DBC27AB5447822BF , 0x 9B3CDB65F82CA382 , 0x B67B7896167B4C84 , 0x BFCED1B0048EAC50 ,
    0x A9119B60369FFEBD , 0x 1FFF7AC80904BF45 , 0x AC12FB171817EEE7 , 0x AF08DA9177DDA93D ,
    0x 1B0CAB936E65C744 , 0x B559EB1D04E5E932 , 0x C37B45B3F8D6F2BA , 0x C3A9DC228CAAC9E9 ,
    0x F3B8B6675A6507FF , 0x 9FC477DE4ED681DA , 0x 67378D8ECCEF96CB , 0x 6DD856D94D259236 ,
    0x A319CE15B0B4DB31 , 0x 073973751F12DD5E , 0x 8A8E849EB32781A5 , 0x E1925C71285279F5 ,
    0x 74C04BF1790C0EFE , 0x 4DDA48153C94938A , 0x 9D266D6A1CC0542C , 0x 7440FB816508C4FE ,
    0x 13328503DF48229F , 0x D6BF7BAEE43CAC40 , 0x 4838D65F6EF6748F , 0x 1E152328F3318DEA ,
    0x 8F8419A348F296BF , 0x 72C8834A5957B511 , 0x D7A023A73260B45C , 0x 94EBC8ABCFB56DAE ,
    0x 9FC10D0F989993E0 , 0x DE68A2355B93CAE6 , 0x A44CFE79AE538BBE , 0x 9D1D84FCCE371425 ,
    0x 51D2B1AB2DDFB636 , 0x 2FD7E4B9E72CD38C , 0x 65CA5B96B7552210 , 0x DD69A0D8AB3B546D ,
    0x 604D51B25FBF70E2 , 0x 73AA8A564FB7AC9E , 0x 1A8C1E992B941148 , 0x AAC40A2703D9BEA0 ,
    0x 764DBEAE7FA4F3A6 , 0x 1E99B96E70A9BE8B , 0x 2C5E9DEB57EF4743 , 0x 3A938FEE32D29981 ,
    0x 26E6DB8FFDF5ADFE , 0x 469356C504EC9F9D , 0x C8763C5B08D1908C , 0x 3F6C6AF859D80055 ,
    0x 7F7CC39420A3A545 , 0x 9BFB227EBDF4C5CE , 0x 89039D79D6FC5C5C , 0x 8FE88B57305E2AB6 ,
    0x A09E8C8C35AB96DE , 0x FA7E393983325753 , 0x D6B6D0ECC617C699 , 0x DFEA21EA9E7557E3 ,
    0x B67C1FA481680AF8 , 0x CA1E3785A9E724E5 , 0x 1CFC8BED0D681639 , 0x D18D8549D140CAEA ,
    0x 4ED0FE7E9DC91335 , 0x E4DBF0634473F5D2 , 0x 1761F93A44D5AEFE , 0x 53898E4C3910DA55 ,
    0x 734DE8181F6EC39A , 0x 2680B122BAA28D97 , 0x 298AF231C85BAFAB , 0x 7983EED3740847D5 ,
    0x 66C1A2A1A60CD889 , 0x 9E17E49642A3E4C1 , 0x EDB454E7BADC0805 , 0x 50B704CAB602C329 ,
    0x 4CC317FB9CDDD023 , 0x 66B4835D9EAFEA22 , 0x 219B97E26FFC81BD , 0x 261E4E4C0A333A9D ,
    0x 1FE2CCA76517DB90 , 0x D7504DFA8816EDBB , 0x B9571FA04DC089C8 , 0x 1DDC0325259B27DE ,
    0x CF3F4688801EB9AA , 0x F4F5D05C10CAB243 , 0x 38B6525C21A42B0E , 0x 36F60E2BA4FA6800 ,
    0x EB3593803173E0CE , 0x 9C4CD6257C5A3603 , 0x AF0C317D32ADAA8A , 0x 258E5A80C7204C4B ,
    0x 8B889D624D44885D , 0x F4D14597E660F855 , 0x D4347F66EC8941C3 , 0x E699ED85B0DFB40D ,
    0x 2472F6207C2D0484 , 0x C2A1E7B5B459AEB5 , 0x AB4F6451CC1D45EC , 0x 63767572AE3D6174 ,
    0x A59E0BD101731A28 , 0x 116D0016CB948F09 , 0x 2CF9C8CA052F6E9F , 0x 0B090A7560A968E3 ,
    0x ABEEDDB2DDE06FF1 , 0x 58EFC10B06A2068D , 0x C6E57A78FBD986E0 , 0x 2EAB8CA63CE802D7 ,
    0x 14A195640116F336 , 0x 7C0828DD624EC390 , 0x D74BBE77E6116AC7 , 0x 804456AF10F5FB53 ,
    0x EBE9EA2ADF4321C7 , 0x 03219A39EE587A30 , 0x 49787FEF17AF9924 , 0x A1E9300CD8520548 ,
    0x 5B4elves22E4B1B4EF , 0x B49C3B3995091A36 , 0x D4490AD526F14431 , 0x 12A8F216AF9418C2 ,
    0x 001F837CC7350524 , 0x 1877B51E57A764D5 , 0x A2853B80F17F58EE , 0x 993E1DE72D36D310 ,
    0x B3598080CE64A656 , 0x 252F59CF0D9F04BB , 0x D23C8E176D113600 , 0x 1BDA0492E7E4586E ,
    0x 21E0BD5026C619BF , 0x 3B097ADAF088F94E , 0x 8D14DEDB30BE846E , 0x F95CFFA23AF5F6F4 ,
    0x 3871700761B3F743 , 0x CA672B91E9E4FA16 , 0x 64C8E531BFF53B55 , 0x 241260ED4AD1E87D ,
    0x 106C09B972D2E822 , 0x 7FBA195410E5CA30 , 0x 7884D9BC6CB569D8 , 0x 0647DFEDCD894A29 ,
    0x 63573FF03E224774 , 0x 4FC8E9560F91B123 , 0x 1DB956E450275779 , 0x B8D91274B9E9D4FB ,
    0x A2EBEE47E2FBFCE1 , 0x D9F1F30CCD97FB09 , 0x EFED53D75FD64E6B , 0x 2E6D02C36017F67F ,
    0x A9AA4D20DB084E9B , 0x B64BE8D8B25396C1 , 0x 70CB6AF7C2D5BCF0 , 0x 98F076A4F7A2322E ,
    0x BF84470805E69B5F , 0x 94C3251F06F90CF3 , 0x 3E003E616A6591E9 , 0x B925A6CD0421AFF3 ,
    0x 61BDD1307C66E300 , 0x BF8D5108E27E0D48 , 0x 240AB57A8B888B20 , 0x FC87614BAF287E07 ,
    0x EF02CDD06FFDB432 , 0x A1082C0466DF6C0A , 0x 8215E577001332C8 , 0x D39BB9C3A48DB6CF ,
    0x 2738259634305C14 , 0x 61CF4F94C97DF93D , 0x 1B6BACA2AE4E125B , 0x 758F450C88572E0B ,
    0x 959F587D507A8359 , 0x B063E962E045F54D , 0x 60E8ED72C0DFF5D1 , 0x 7B64978555326F9F ,
    0x FD080D236DA814BA , 0x 8C90FD9B083F4558 , 0x 106F72FE81E2C590 , 0x 7976033A39F7D952 ,
    0x A4EC0132764CA04B , 0x 733EA705FAE4FA77 , 0x B4D8F77BC3E56167 , 0x 9E21F4F903B33FD9 ,
    0x 9D765E419FB69F6D , 0x D30C088BA61EA5EF , 0x 5D94337FBFAF7F5B , 0x 1A4E4822EB4D7A59 ,
    0x 6FFE73E81B637FB3 , 0x DDF957BC36D8B9CA , 0x 64D0E29EEA8838B3 , 0x 08DD9BDFD96B9F63 ,
    0x 087E79E5A57D1D13 , 0x E328E230E3E2B3FB , 0x 1C2559E30F0946BE , 0x 720BF5F26F4D2EAA ,
    0x B0774D261CC609DB , 0x 443F64EC5A371195 , 0x 4112CF68649A260E , 0x D813F2FAB7F5C5CA ,
    0x 660D3257380841EE , 0x 59AC2C7873F910A3 , 0x E846963877671A17 , 0x 93B633ABFA3469F8 ,
    0x C0C0F5A60EF4CDCF , 0x CAF21ECD4377B28C , 0x 57277707199B8175 , 0x 506C11B9D90E8B1D ,
    0x D83CC2687A19255F , 0x 4A29C6465A314CD1 , 0x ED2DF21216235097 , 0x B5635C95FF7296E2 ,
    0x 22AF003AB672E811 , 0x 52E762596BF68235 , 0x 9AEBA33AC6ECC6B0 , 0x 944F6DE09134DFB6 ,
    0x 6C47BEC883A7DE39 , 0x 6AD047C430A12104 , 0x A5B1CFDBA0AB4067 , 0x 7C45D833AFF07862 ,
    0x 5092EF950A16DA0B , 0x 9338E69C052B8E7B , 0x 455A4B4CFE30E3F5 , 0x 6B02E63195AD0CF8 ,
    0x 6B17B224BAD6BF27 , 0x D1E0CCD25BB9C169 , 0x DE0C89A556B9AE70 , 0x 50065E535A213CF6 ,
    0x 9C1169FA2777B874 , 0x 78EDEFD694AF1EED , 0x 6DC93D9526A50E68 , 0x EE97F453F06791ED ,
    0x 32AB0EDB696703D3 , 0x 3A6853C7E70757A7 , 0x 31865CED6120F37D , 0x 67FEF95D92607890 ,
    0x 1F2B1D1F15F6DC9C , 0x B69E38A8965C6B65 , 0x AA9119FF184CCCF4 , 0x F43C732873F24C13 ,
    0x FB4A3D794A9A80D2 , 0x 3550C2321FD6109C , 0x 371F77E76BB8417E , 0x 6BFA9AAE5EC05779 ,
    0x CD04F3FF001A4778 , 0x E3273522064480CA , 0x 9F91508BFFCFC14A , 0x 049A7F41061A9E60 ,
    0x FCB6BE43A9F2FE9B , 0x 08DE8A1C7797DA9B , 0x 8F9887E6078735A1 , 0x B5B4071DBFC73A66 ,
    0x 230E343DFBA08D33 , 0x 43ED7F5A0FAE657D , 0x 3A88A0FBBCB05C63 , 0x 21874B8B4D2DBC4F ,
    0x 1BDEA12E35F6A8C9 , 0x 53C065C6C8E63528 , 0x E34A1D250E7A8D6B , 0x D6B04D3B7651DD7E ,
    0x 5E90277E7CB39E2D , 0x 2C046F22062DC67D , 0x B10BB459132D0A26 , 0x 3FA9DDFB67E2F199 ,
    0x 0E09B88E1914F7AF , 0x 10E8B35AF3EEAB37 , 0x 9EEDECA8E272B933 , 0x D4C718BC4AE8AE5F ,
    0x 81536D601170FC20 , 0x 91B534F885818A06 , 0x EC8177F83F900978 , 0x 190E714FADA5156E ,
    0x B592BF39B0364963 , 0x 89C350C893AE7DC1 , 0x AC042E70F8B383F2 , 0x B49B52E587A1EE60 ,
    0x FB152FE3FF26DA89 , 0x 3E666E6F69AE2C15 , 0x 3B544EBE544C19F9 , 0x E805A1E290CF2456 ,
    0x 24B33C9D7ED25117 , 0x E74733427B72F0C1 , 0x 0A804D18B7097475 , 0x 57E3306D881EDB4F ,
    0x 4AE7D6A36EB5DBCB , 0x 2D8D5432157064C8 , 0x D1E649DE1E7F268B , 0x 8A328A1CEDFE552C ,
    0x 07A3AEC79624C7DA , 0x 84547DDC3E203C94 , 0x 990A98FD5071D263 , 0x 1A4FF12616EEFC89 ,
    0x F6F7FD1431714200 , 0x 30C05B1BA332F41C , 0x 8D2636B81555A786 , 0x 46C9FEB55D120902 ,
    0x CCEC0A73B49C9921 , 0x 4E9D2827355FC492 , 0x 19BB029435DCB0F , 0x 4659D2B743848A2C ,
    0x 963EF2C96B33BE31 , 0x 74F85198B05A2E7D , 0x 5A0F544DD2B1FB18 , 0x 03727073C2E134B1 ,
    0x C7F6AA2DE59AEA61 , 0x 352787BAA0D7C22F , 0x 9853EAB63B5E0B35 , 0x ABBDCDD7ED5C0860 ,
    0x CF05DAF5AC8D77B0 , 0x 49CAD48CEBF4A71E , 0x 7A4C10EC2158C4A6 , 0x D9E92AA246BF719E ,
    0x 13AE978D09FE5557 , 0x 730499AF921549FF , 0x 4E4B705B92903BA4 , 0x FF577222C14F0A3A ,
    0x 55B6344CF97AAFAE , 0x B862225B055B6960 , 0x CAC09AFBDDD2CDB4 , 0x DAF8E9829FE96B5F ,
    0x B5FDFC5D3132C498 , 0x 310CB380DB6F7503 , 0x E87FBB46217A360E , 0x 2102AE466EBB1148 ,
    0x F8549E1A3AA5E00D , 0x 07A69AFDCC42261A , 0x C4C118BFE78FEAAE , 0x F9F4892ED96BD438 ,
    0x 1AF3DBE25D8F45DA , 0x F5B4B0B0D2DEEEB4 , 0x 962ACEEFA82E1C84 , 0x 046E3ECAAF453CE9 ,
    0x F05D129681949A4C , 0x 964781CE734B3C84 , 0x 9C2ED44081CE5FBD , 0x 522E23F3925E319E ,
    0x 177E00F9FC32F791 , 0x 2BC60A63A6F3B3F2 , 0x 222BBFAE61725606 , 0x 486289DDCC3D6780 ,
    0x 7DC7785B8EFDFC80 , 0x 8AF38731C02BA980 , 0x 1FAB64EA29A2DDF7 , 0x E4D9429322CD065A ,
    0x 9DA058C67844F20C , 0x 24C0E332B70019B0 , 0x 233003B5A6CFE6AD , 0x D586BD01C5C217F6 ,
    0x 5E5637885F29BC2B , 0x 7EBA726D8C94094B , 0x 0A56A5F0BFE39272 , 0x D79476A84EE20D06 ,
    0x 9E4C1269BAA4BF37 , 0x 17EFEE45B0DEE640 , 0x 1D95B0A5FCF90BC6 , 0x 93CBE0B699C2585D ,
    0x 65FA4F227A2B6D79 , 0x D5F9E858292504D5 , 0x C2B5A03F71471A6F , 0x 59300222B4561E00 ,
    0x CE2F8642CA0712DC , 0x 7CA9723FBB2E8988 , 0x 2785338347F2BA08 , 0x C61BB3A141E50E8C ,
    0x 150F361DAB9DEC26 , 0x 9F6A419D382595F4 , 0x 64A53DC924FE7AC9 , 0x 142DE49FFF7A7C3D ,
    0x 0C335248857FA9E7 , 0x 0A9C32D5EAE45305 , 0x E6C42178C4BBB92E , 0x 71F1CE2490D20B07 ,
    0x F1BCC3D275AFE51A , 0x E728E8C83C334074 , 0x 96FBF83A12884624 , 0x 81A1549FD6573DA5 ,
    0x 5FA7867CAF35E149 , 0x 56986E2EF3ED091B , 0x 917F1DD5F8886C61 , 0x D20D8C88C8FFE65F ,
    0x 31D71DCE64B2C310 , 0x F165B587DF898190 , 0x A57E6339DD2CF3A0 , 0x 1EF6E6DBB1961EC9 ,
    0x 70CC73D90BC26E24 , 0x E21A6B35DF0C3AD7 , 0x 003A93D8B2806962 , 0x 1C99DED33CB890A1 ,
    0x CF3145DE0ADD4289 , 0x D0E4427A5514FB72 , 0x 77C621CC9FB3A483 , 0x 67A34DAC4356550B ,
    0x F8D626AAAF278509
]


classe  ZobristHasher :
    def  __init__ ( self , array : List [ int ]) -> Aucun :
        assert  len (tableau) > =  781
        self .array = tableau

    def  hash_board ( self , board : chess.BaseBoard) -> int :
        zobrist_hash =  0

        pour pivot, carrés en  énumérés (board.occupied_co):
            pour square dans chess.scan_reversed (carrés):
                piece_index = (typing.cast (chess.PieceType, board.piece_type_at (carré)) -  1 ) *  2  + pivot
                zobrist_hash ^ =  self .array [ 64  * piece_index + square]

        retourne zobrist_hash

    def  hash_castling ( self , board : chess.Board) -> int :
        zobrist_hash =  0

        # Hash dans les drapeaux de castling.
        si board.has_kingside_castling_rights (échecs. BLANC ):
            zobrist_hash ^ =  self .array [ 768 ]
        si board.has_queenside_castling_rights (échecs. BLANC ):
            zobrist_hash ^ =  self .array [ 768  +  1 ]
        si board.has_kingside_castling_rights (échecs. NOIR ):
            zobrist_hash ^ =  self .array [ 768  +  2 ]
        si board.has_queenside_castling_rights (échecs. NOIR ):
            zobrist_hash ^ =  self .array [ 768  +  3 ]

        retourne zobrist_hash

    def  hash_ep_square ( self , board : chess.Board) -> int :
        # Hash dans le fichier en passant.
        si board.ep_square:
            # Mais seulement s’il ya un pion prêt à le capturer. Légalité
            Le nombre de captures potentielles est sans importance.
            si board.turn == échecs. BLANC :
                ep_mask = chess.shift_down (échecs. BB_SQUARES [board.ep_square])
            sinon :
                ep_mask = chess.shift_up (échecs. BB_SQUARES [board.ep_square])
            ep_mask = chess.shift_left (ep_mask) | chess.shift_right (ep_mask)

            si ep_mask & board.pawns & board.occupied_co [board.turn]:
                return  self .array [ 772  + chess.square_file (board.ep_square)]
        retourne  0

    def  hash_turn ( self , board : chess.Board) -> int :
        # Hash dans le tour.
        retourne  self .array [ 780 ] si board.turn == échecs. BLANC  sinon  0

    def  __call__ ( self , board : chess.Board) -> int :
        return ( self .hash_board (board) ^  self .hash_castling (board) ^
                auto .hash_ep_square (conseil) ^  auto .hash_turn (conseil))


def  zobrist_hash ( conseil : chess.Board, * , _hasher : appelable [[chess.Board], int ] = ZobristHasher ( POLYGLOT_RANDOM_ARRAY )) -> int :
    "" "
    Calcule le hachage de Zobrist Polyglot de la position.
    Un hash de Zobrist est un XOR de valeurs pseudo-aléatoires choisies dans
    un tableau. Les valeurs choisies sont déterminées par les caractéristiques du
    position, tels que positions des pièces, droits de castling et en passant
    des carrés.
    "" "
    retourne _hasher (planche)


Classe  Entry ( collections . namedtuple ( " Entry " , " clé poids brut_déplacez apprenez le mouvement " )):
    "" " Une entrée d'un livre d'ouverture Polyglot. " ""

    __slots__  = ()


classe  _EmptyMmap ( bytearray ):
     taille def ( auto ):
        retourne  0

    def  close ( auto ):
        passer


Classe  MemoryMappedReader :
    "" " Mappe un livre d'ouverture polyglotte à la mémoire. " ""

    def  __init__ ( self , nom de fichier : PathLike) -> None :
        self .fd = os.open (nomfichier, os. O_RDONLY  | os. O_BINARY  si  hasattr (os, " O_BINARY " ) sinon os. O_RDONLY )

        essayez :
            self .mmap = mmap.mmap ( self .fd, 0 , access = mmap. ACCESS_READ )   # type:  Facultatif [ mmap . mmap ]
        sauf ( ValueError , mmap.error):   # type:  ignorer
            self .mmap = _EmptyMmap ()   # Solution de contournement pour les livres d'ouverture vides.

        essayez :
            # Python 3.8
            auto .mmap.madvise (mmap. MADV_RANDOM )
        sauf  AttributeError :
            passer

    def  __enter__ ( self ) -> " MemoryMappedReader " :
        retourner  soi-même

    def  __exit__ ( auto , exc_type : option [Type [ BaseException ]], exc_value : option [ BaseException ], retraçage : option [TracebackType]) -> Aucun :
        retourne  moi-même .close ()

    def  __len__ ( self ) -> int :
        return  self .mmap.size () //  ENTRY_STRUCT .size

    def  __getitem__ ( self , index : int ) -> Entrée:
        si index <  0 :
            index =  len ( self ) + index

        essayez :
            clé, raw_move, weight, learn =  ENTRY_STRUCT .unpack_from ( self .mmap, index *  ENTRY_STRUCT .size)   # type:  ignorer
        sauf struct.error:
            soulève  IndexError ()

        # Extrait le carré source et cible.
        to_square = raw_move &  0x 3f
        from_square = (raw_move >>  6 ) &  0x 3f

        # Extraire le type de promotion.
        promotion_part = (raw_move >>  12 ) &  0x 7
        promotion = promotion_part +  1  si promotion_part else  Aucun

        # Pièce baisse.
        si from_square == to_square:
            promotion, drop =  Aucun , promotion
        sinon :
            drop =  Aucun

        # Entrée avec déplacement (non normalisé).
        move = chess.Move (from_square, to_square, promotion, drop)
        retourne Entrée (clé, raw_move, weight, learn, move)

    def  __iter__ ( self ) -> Iterator [Entrée]:
        i =  0
        taille =  len ( auto )
        pendant que je < taille:
            se donner  soi-même [i]
            i + =  1

    def  bisect_key_left ( self , key : int ) -> int :
        lo =  0
        salut =  len ( auto )

        tout en bas < salut:
            mid = (lo + hi) //  2
            mid_key, _, _, _ =  ENTRY_STRUCT .unpack_from ( self .mmap, mid *  ENTRY_STRUCT .size)   # type:  ignorer
            si mid_key < clé:
                lo = milieu +  1
            sinon :
                salut = mi

        retourner lo

    def  __contains__ ( self , entry : Entry) -> bool :
        retourner  tout (courant == entrée de courant dans la  self .find_all (entry.key, minimum_weight = entry.weight))

    def  find_all ( self , board : Union [échecs.Board, int ], * , poids minimum : int  =  1 , exclude_moves : Container [chess.Move] = ()) -> Iterator [Entrée]:
        "" " Recherche une position spécifique et génère les entrées correspondantes. " ""
        essayez :
            clé =  int (tableau)   # type:  ignorer
            context =  None   # type:  Facultatif [ échecs . Conseil ]
        sauf ( TypeError , ValueError ):
            context = typing.cast (chess.Board, board)
            clé = zobrist_hash (contexte)

        i =  self .bisect_key_left (clé)
        taille =  len ( auto )

        pendant que je < taille:
            entry =  self [i]
            i + =  1

            si entry.key ! = key:
                Pause

            si entry.weight < minimum_weight :
                continuer

            si contexte:
                move = context._from_chess960 (context.chess960, entry.move.from_square, entry.move.to_square, entry.move.promotion, entry.move.drop)
                entry = entry (entry.key, entry.raw_move, entry.weight, entry.learn, move)

            si exclude_moves et entry.move dans exclude_moves:
                continuer

            si context et  non context.is_legal (entry.move):
                continuer

            entrée de rendement

    def  find ( self , board : Union [chess.Board, int ], * , poids minimum : int  =  1 , exclude_moves : Container [chess.Move] = ()) -> Entrée:
        "" "
        Trouve l'entrée principale pour la position donnée ou le hachage Zobrist.
        L'entrée principale est la (première) entrée avec le poids le plus élevé.
        Par défaut, les entrées avec le poids `` 0`` sont exclues. Ceci est un commun
        moyen de supprimer des entrées d’un livre d’ouverture sans le compacter. Passer
        * minimum_weight * `` 0`` pour sélectionner toutes les entrées.
        : déclenche:: exc: `IndexError` si aucune entrée n'est trouvée. Utilisation
            : func: `~ chess.polyglot.MemoryMappedReader.get ()` si vous préférez
            obtenez `` None`` au lieu d'une exception.
        "" "
        essayez :
            retour  max ( auto .find_all (planche, minimum_weight = minimum_weight, exclude_moves = exclude_moves) clé = lambda  entrée : entry.weight)
        sauf  ValueError :
            soulève  IndexError ()

    def  get ( self , board : Union [chess.Board, int ], par défaut : Facultatif [Entrée] =  Aucun , * , poids minimum : int  =  1 , exclude_moves : Container [chess.Move] = ()) -> Facultatif [Entrée ]:
        essayez :
            retour  auto .Find (planche, minimum_weight = minimum_weight, exclude_moves = exclude_moves)
        sauf  IndexError :
            retourne le défaut

    def  choix ( self , board : Union [échecs.Board, int ], * , poids minimum : int  =  1 , exclude_moves : Container [chess.Move] = (), random = random) -> Entrée:
        "" "
        Sélectionne uniformément une entrée aléatoire pour la position donnée.
        : déclenche:: exc: `IndexError` si aucune entrée n'est trouvée.
        "" "
        selected_entry =  Aucun

        pour i, l' entrée en  énumérer ( auto .find_all (planche, minimum_weight = minimum_weight, exclude_moves = exclude_moves)):
            si selected_entry est  None  ou random.randint ( 0 , i) == i:
                selected_entry = entry

        si selected_entry est  None :
            soulève  IndexError ()

        retourner choisi_entry

    def  weighted_choice ( self , board : Union [chess.Board, int ], * , exclude_moves : Container [chess.Move] = (), random = random) -> Entrée:
        "" "
        Sélectionne une entrée aléatoire pour la position donnée, distribuée par le
        poids des entrées.
        : déclenche:: exc: `IndexError` si aucune entrée n'est trouvée.
        "" "
        total_weights =  sum (entry.weight pour une entrée dans  self .find_all (board, exclude_moves = exclude_moves))
        si  non total_weights:
            soulève  IndexError ()

        choice = random.randint ( 0 , total_weights -  1 )

        current_sum =  0
        pour une entrée dans  self .find_all (tableau, exclude_moves = exclude_moves):
            current_sum + = entry.weight
            si current_sum > choix:
                entrée de retour

        affirmer  Faux

    def  close ( self ) -> Aucun :
        "" " Ferme le lecteur. " ""
        auto .mmap.close ()

        essayez :
            os.close ( self .fd)
        sauf  OSError :
            passer


def  open_reader ( path : PathLike) -> MemoryMappedReader:
    "" "
    Crée un lecteur pour le fichier dans le chemin donné.
    L'exemple suivant ouvre un livre pour trouver toutes les entrées pour le début
    position:
    >>> échecs d'importation
    >>> import chess.polyglot
    >>>
    >>> board = échecs.Board ()
    >>>
    >>> avec chess.polyglot.open_reader ("data / polyglot / performance.bin") en tant que lecteur:
    ...    pour l'entrée dans reader.find_all (tableau):
    ...        print (entry.move, entry.weight, entry.learn)
    e2e4 1 0
    d2d4 1 0
    c2c4 1 0
    "" "
    retourne MemoryMappedReader (chemin)
